static int $unit$_libop
(
	enum library_operation op,
	const char** errors,
	int max_length
);

static struct lxc_generic_ $unit$_behavior =
{
	.base.library_operation = $unit$_libop,
};

struct $unit$_instance
{
	struct lxc_generic_..._instance base;
};

static LxcValue* access_internal_variable(Gate i, int wire_abs)
{


	return NULL;
}


static void $unit$_execute(Gate instance, Signal type, LxcValue value, uint index)
{

	if(type == &lxc_signal_system)
	{
		struct lxc_system_event* sys =
			(struct lxc_system_event*) lxc_get_value(value);

		enum lxc_system_event_type type = sys->event_type;

		if(system_event_gate_enabled == type)
		{
			operation(gate);
		}
		else if(system_event_output_wire_added == type)
		{
			lxc_portb_republish_internal_value
			(
				instance,
				sys->signal,
				sys->index,
				access_internal_variable
			);
		}
	}

	//TODO
}


static int $unit$_libop
(
	enum library_operation op,
	const char** errors,
	int max_length
)
{
	if(library_before_load == op)
	{
		lxc_init_from_prototype
		(
			(void*)	&$unit$_behavior,
			sizeof	($unit$_behavior),

			(void*)	&lxc_generic_...,
			sizeof	(lxc_generic_...)
		);

		$unit$_behavior.base.library_operation = $unit$_libop;
		$unit$_behavior.base.gate_name = "unit name";
		$unit$_behavior.base.paths = $unit$_path;

		$unit$_behavior.instance_memory_size =
			sizeof(struct $unit$_instance);

		$unit$_behavior.base.execute = $unit$_execute;


		//TODO lxc_port_unchecked_add_new_port
		
		//TODO lxc_add_property
	}
	return 0;
}


void* produce_$unit$()
{
	return (void*) &$unit$_behavior;
}
